<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>如何用Markdown去写一篇文章</title>
    <url>/2020/04/15/markdown%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　<strong>Markdown</strong>是一种<a href="https://zh.wikipedia.org/wiki/轻量级标记语言" target="_blank" rel="noopener">轻量级标记语言</a>,可以让人们专注于写文章而不是排版上,而且还可以转换成各种其他格式.</p>
<p>　　由于<strong>Markdown</strong>的轻量化、易读易写特性，并且对于<em>图片，图表、数学式</em>都有支持，当前许多网站都广泛使用<strong>Markdown</strong>来撰写帮助文档或是用于<a href="https://zh.wikipedia.org/wiki/网络论坛" target="_blank" rel="noopener">论坛</a>上发表消息。如<a href="https://zh.wikipedia.org/wiki/GitHub" target="_blank" rel="noopener">GitHub</a>、<a href="https://zh.wikipedia.org/wiki/Reddit" target="_blank" rel="noopener">Reddit</a>、<a href="https://zh.wikipedia.org/wiki/Diaspora" target="_blank" rel="noopener">Diaspora</a>、<a href="https://zh.wikipedia.org/wiki/Stack_Exchange" target="_blank" rel="noopener">Stack Exchange</a>、<a href="https://zh.wikipedia.org/wiki/OpenStreetMap" target="_blank" rel="noopener">OpenStreetMap</a> 、<a href="https://zh.wikipedia.org/wiki/SourceForge" target="_blank" rel="noopener">SourceForge</a>、<a href="https://zh.wikipedia.org/wiki/简书" target="_blank" rel="noopener">简书</a>等，甚至还能被使用来撰写<a href="https://zh.wikipedia.org/wiki/電子書" target="_blank" rel="noopener">电子书</a>。</p>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用<strong>#+空格+标题</strong>的形式实现,几个#代表几级标题,总共有<strong>六级标题</strong></p>
</blockquote>
<a id="more"></a>



<p><span id="html"></span></p>
<h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br><span class="line"><span class="strong">**粗体**</span></span><br><span class="line"><span class="strong">***粗斜体**</span>*</span><br><span class="line">~~删除线~~</span><br><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><em>斜体</em></p>
<p><strong>粗体</strong></p>
<p><strong><em>粗斜体</em></strong></p>
<p><del>删除线</del></p>
<p><u>下划线</u></p>
<h3 id="链接与图片"><a href="#链接与图片" class="headerlink" title="链接与图片"></a>链接与图片</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">网站名</span>](<span class="link">网址链接</span>)</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">网址链接</span>&gt;</span></span> <span class="xml"><span class="comment">&lt;!--一种快捷方法,直接输入网址--&gt;</span></span></span><br><span class="line"></span><br><span class="line">![<span class="string">图片名</span>](<span class="link">本地图片位置或网络图片地址</span>)</span><br><span class="line"></span><br><span class="line">[<span class="string">网站名字</span>][<span class="symbol">a</span>] <span class="xml"><span class="comment">&lt;!--通过引用的方法--&gt;</span></span></span><br><span class="line">[<span class="symbol">a</span>]:<span class="link">网站链接</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>　　链接和图片除了1,4行那种普通方法,还可以用如6,7行所示的引用方法.这种方法的好处就是编写时界面整洁  ( <em>[a]:网站链接</em> 可以放在任意位置,在成品中是不会显示出来的)</p>
</blockquote>
<p><a href="https://www.bilibili.com" target="_blank" rel="noopener">哔哩哔哩</a></p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">+ </span>无序列表</span><br><span class="line"><span class="bullet">+ </span>无序列表</span><br><span class="line"> +无序列表的子列表</span><br><span class="line"> </span><br><span class="line"><span class="bullet">1. </span>有序列表</span><br><span class="line"><span class="bullet">2. </span>有序列表</span><br><span class="line"> 1.有序列表的子列表</span><br></pre></td></tr></table></figure>

<blockquote>
<p>　　列表分<strong>无序列表</strong>和<strong>有序列表</strong>,无序列表为一个加号<strong>+</strong>或减号<strong>-</strong>或星号<strong>*** + **空格</strong> + <strong>文字</strong>,然后就可以直接换行它会自动生成一个小圆点在前面,同时你也可以在最前面加上空格来做出列表的子集</p>
</blockquote>
<ul>
<li><p>列表</p>
</li>
<li><p>列表</p>
<ul>
<li>子列表</li>
</ul>
</li>
</ul>
<ol>
<li>有序列表</li>
<li>有序列表<ol>
<li>有序列表的子列表</li>
</ol>
</li>
</ol>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 引用内容</span></span><br><span class="line">&gt;&gt; 下一级引用</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用内容</p>
<blockquote>
<p>下一级引用</p>
</blockquote>
</blockquote>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`代码区块`</span></span><br><span class="line"></span><br><span class="line">​<span class="code">```</span>`java</span><br></pre></td></tr></table></figure>

<blockquote>
<p>　　代码块有两种,一种就是前面一直在用的<strong>代码块</strong>,为四个<strong>`</strong>符号( 键盘左上角的那个键 ) + <strong>代码语言</strong>,还有一种就是<strong>代码区块</strong></p>
</blockquote>
<p><code>代码区块</code></p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
<blockquote>
<p>表格用手打比较累,一般用快捷键生成</p>
</blockquote>
<h3 id="段落与缩进"><a href="#段落与缩进" class="headerlink" title="段落与缩进"></a>段落与缩进</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&amp;nbsp</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>两个空格</strong>+<strong>回车</strong>可以另起一个段落,<strong>缩进</strong>有很多种方式在这里推荐一种方式:切换到<strong>圆角状态</strong>后打<strong>两个空格</strong></p>
</blockquote>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">***</span></span><br><span class="line">---</span><br><span class="line"><span class="emphasis">___</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>三个以上的星号<strong>***或减号</strong>-<strong>或下划线</strong>_**</p>
</blockquote>
<hr>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">脚注[^a]</span><br><span class="line">[<span class="symbol">^a</span>]:<span class="link">这是一个脚注</span></span><br></pre></td></tr></table></figure>

<p>脚注<a href="这是一个脚注">^a</a></p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>　　<strong>Markdown</strong>语法是支持<strong>html</strong>语法的,所以有些效果可以用html来展出出来,上面<a href="#html">字体样式</a>里的下划线便是一个例子,而且还可以在html里写<strong>行内样式</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">sytle</span>=<span class="string">"border: 1px solid black"</span>&gt;</span></span>行内样式<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><span style="border: 1px solid black">行内样式</span></p>
<h3 id="编辑器推荐"><a href="#编辑器推荐" class="headerlink" title="编辑器推荐"></a>编辑器推荐</h3><p>　　最后来推荐一下写markdown的<strong>编辑器,</strong>市面上有很多,很多<strong>代码编辑器</strong>都支持markdown语法,像<em>vscode,atom,sublime</em>这些都是可以用来写markdown的,不过我在这里推荐<a href="https://typora.io/" target="_blank" rel="noopener"><strong>Typora</strong></a>这个编辑器,有以下几个优点.</p>
<ol>
<li>外观简洁</li>
<li>软件占用小</li>
<li>功能齐全</li>
<li>可以导出各种样式</li>
<li>快捷键丰富</li>
</ol>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>css的弹性布局</title>
    <url>/2020/04/18/%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　css的<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout" target="_blank" rel="noopener">布局方式</a>有很多种,今天来谈谈<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout" target="_blank" rel="noopener">弹性布局</a>.<strong>2009</strong>年，<strong>W3C</strong> 提出了一种新的方案—-<strong>Flex</strong> 布局，可以<em>简便、完整、响应式</em>地实现各种页面布局.相对于传统的布局,弹性布局更加灵活,可以更加轻松的实现某些功能.</p>
<br>

<h2 id="如何启用弹性布局"><a href="#如何启用弹性布局" class="headerlink" title="如何启用弹性布局"></a>如何启用弹性布局</h2><blockquote>
<p>当某一个元素的<strong>display</strong>为<strong>flex</strong>时,这个元素就成了一个<strong>flex容器</strong>,在它里面便可以进行弹性布局.</p>
</blockquote>
<p><img src="/img/%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/display.gif" alt="display"></p>
<a id="more"></a>

<br>

<h2 id="弹性布局的一些特性"><a href="#弹性布局的一些特性" class="headerlink" title="弹性布局的一些特性"></a>弹性布局的一些特性</h2><blockquote>
<p>设置弹性布局后,弹性元素的<strong>float</strong>,<strong>clear</strong>和<strong>vertical-align</strong>将失效.</p>
<p>弹性布局内不存在<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing" target="_blank" rel="noopener"><strong>边界重叠</strong></a></p>
</blockquote>
<br>

<h2 id="容器与项目"><a href="#容器与项目" class="headerlink" title="容器与项目"></a>容器与项目</h2><p><img src="/img/%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/%E5%AE%B9%E5%99%A8.png" alt="flex容器与项目"></p>
<ul>
<li><p>flex容器的子元素自动成为<strong>flex项目</strong></p>
</li>
<li><p>容器默认有两根轴,水平的<strong>主轴</strong>(main axis)和竖直的<strong>交叉轴</strong>(cross axis),轴的方向并不是固定的,呆会会讲到</p>
</li>
<li><p>项目默认沿主轴排列</p>
</li>
</ul>
<br>

<h2 id="flex的属性"><a href="#flex的属性" class="headerlink" title="flex的属性"></a>flex的属性</h2><blockquote>
<p>flex主要有以下几个属性:</p>
</blockquote>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-shrink</li>
<li>flex-grow</li>
<li>flex-basis</li>
<li>justify-content</li>
<li>align-items</li>
</ul>
<br>

<h3 id="flex的方向与换行"><a href="#flex的方向与换行" class="headerlink" title="flex的方向与换行"></a>flex的方向与换行</h3><p>　　flex项目默认是沿主轴排列的,事实上它一直都是如此,无法改变.那如果我想让他不再横着排列而是竖着该怎么办呢?虽然改变不了flex项目沿着主轴排列这个事实,但那我们可以<strong>改变主轴和交叉轴的方向</strong>.</p>
<br>

<h4 id="flex-directioin"><a href="#flex-directioin" class="headerlink" title="flex-directioin"></a>flex-directioin</h4><blockquote>
<p><strong>flex-direction</strong>就是为此而生的,它可以改变轴的方向,有如下几个<strong>值</strong>:</p>
</blockquote>
<p><img src="/img/%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/direction1.gif" alt="flex-direction"></p>
<p><img src="/img/%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/direction2.gif" alt="flex-direction"></p>
<ul>
<li><strong>row</strong>(原始状态,主轴从左到右横向,交叉轴从上到下纵向)</li>
<li><strong>row-reverse</strong>(主轴从右到左横向,交叉轴从上到下纵向)</li>
<li><strong>column</strong>(主轴从上到下纵向,交叉轴从左到右横向)</li>
<li><strong>column-reverse</strong>(主轴从下到上纵向,交叉轴从左到右横向)</li>
<li><br>

</li>
</ul>
<h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><blockquote>
<p>接下来是换行,当flex项目占满一行后如何改变,就看<strong>flex-wrap</strong>这个属性了,有如下几个<strong>值</strong>:</p>
</blockquote>
<ul>
<li><strong>nowrap</strong>(默认,不换行)</li>
</ul>
<p><img src="/img/%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/wrap1.png" alt="nowrap"></p>
<ul>
<li><strong>wrap</strong>(换行,第一行在上方)</li>
</ul>
<p><img src="/img/%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/wrap2.jpg" alt="wrap"></p>
<ul>
<li><strong>wrap-reverse</strong>(换行,第一行在下方)</li>
</ul>
<p><img src="/img/%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/wrap3.jpg" alt="wrap-reverse"></p>
<h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><blockquote>
<p>还有一个属性: <strong>flex-flow</strong>,为前面两个属性的<strong>简写形式</strong></p>
</blockquote>
<p><code>flex-flow: flex-direction flex-wrap;</code></p>
<br>

<h3 id="flex的缩放与大小"><a href="#flex的缩放与大小" class="headerlink" title="flex的缩放与大小"></a>flex的缩放与大小</h3><blockquote>
<p><strong>注意! 以下属性都是属于flex项目的,要写在flex项目里.</strong></p>
</blockquote>
<p>　　flex容器默认是不换行的,那么当一行挤不下的时候会怎样呢?当然不是让它溢出来,而是会自动的缩放,而且你还可以自己调整每个flex项目缩放的比例.</p>
<br>

<h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>　　flex项目的<strong>flex-shrink默认是1</strong>,也就是说,当flex项目一行排不下又不能换行时,它们会<strong>等比的进行缩小</strong>,值得一提的是,flex-shrink: 1并非是严格等比缩小,它还会<strong>考虑flex项目本身的的大小</strong>,这样的目的是为了一些原本就很小的元素不至于到最后宽度变为0.</p>
<p>　　那么假设有flex容器的宽度为200px,有三个flex项目,分别是50px,100px,120px.那么flex项目1是以如下方式缩小的:</p>
<ul>
<li>超出的宽度: 50px+100px+120px-200px=70px</li>
<li>缩小因子分母: 1*50+1*100+1*120=270(1为各flex项目的flex-strink)</li>
<li>缩小因子: 1*50/270</li>
<li>最终缩小宽度: 缩小因子*超出宽度</li>
</ul>
<p><img src="/img/%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/shrink.gif" alt="flex-shrink"></p>
<br>

<h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>　　<strong>flex-grow默认是0</strong>,也就是说当容器有剩余时是<strong>不自动放大</strong>的,flex-grow的<strong>放大方法</strong>没有和flex-shrink一样将元素自身大小计算在内,只是根据flex-grow声明的份数计算出每个元素需要要分配多少,:</p>
<ul>
<li>容器剩余宽度</li>
<li>分成每份: 容器剩余宽度/所有flex-grow的值相加</li>
<li>最终放大宽度: 每份*flex-grow</li>
</ul>
<blockquote>
<p>没有多余宽度时使用flex-grow无效</p>
</blockquote>
<p><img src="/img/%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/grow.gif" alt="flex-grow"></p>
<br>

<h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><blockquote>
<p> flex-basis可以在元素缩放之前规定<strong>元素的初始尺寸</strong>,类似与height和width,但也有如下区别(以width为例):</p>
</blockquote>
<ul>
<li>两者都为0<ul>
<li>width: 不显示</li>
<li>flex-basis: 根据内容撑开宽度</li>
</ul>
</li>
<li>两者都非0<ul>
<li>数值相同时: 等效</li>
<li>数值不同时: flex-basis优先级高</li>
</ul>
</li>
<li>flex-basis为auto时(默认)<ul>
<li>有width: 由width决定</li>
<li>没有width: 根据内容撑开</li>
</ul>
</li>
</ul>
<p><img src="/img/%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/basis1.gif" alt="flex-basis"></p>
<blockquote>
<p>flex-basis<strong>并不等于width</strong>,而是主轴上的一段距离,当主轴方向改成column后,此时设置的是元素的height</p>
</blockquote>
<p><img src="/img/%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/basis2.gif" alt="flex-basis"></p>
<br>

<h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><blockquote>
<p><strong>简写属性</strong>,即:</p>
</blockquote>
<p><code>flex: flex-grow flex-shrink flex-basis;</code></p>
<blockquote>
<p>同时它自身还有一些<strong>简写</strong>:</p>
</blockquote>
<ul>
<li><code>flex: 1;</code> = <code>flex: 1 1 0%;</code></li>
<li><code>flex: 2;</code> = <code>flex: 2 1 0%;</code></li>
<li><code>flex: auto</code> = <code>flex: 1 1 auto;</code></li>
<li><code>flex: none</code> = <code>flex: 0 0 auto;</code></li>
</ul>
<blockquote>
<p>具体可以表现为以下<strong>规律</strong>:</p>
</blockquote>
<ul>
<li>当 <code>flex</code> 取值为一个非负数字，则该数字为 <code>flex-grow</code> 值，<code>flex-shrink</code> 取 1，<code>flex-basis</code> 取 0%</li>
<li>当 <code>flex</code> 取值为一个长度或百分比，则视为 <code>flex-basis</code> 值，<code>flex-grow</code> 取 1，<code>flex-shrink</code> 取 1</li>
<li>当 <code>flex</code> 取值为两个非负数字，则分别视为 <code>flex-grow</code> 和 <code>flex-shrink</code> 的值，<code>flex-basis</code> 取 0%</li>
<li>当 <code>flex</code> 取值为一个非负数字和一个长度或百分比，则分别视为 <code>flex-grow</code> 和 <code>flex-basis</code> 的值，<code>flex-shrink</code> 取 1</li>
</ul>
<br>

<h3 id="flex的对齐方式"><a href="#flex的对齐方式" class="headerlink" title="flex的对齐方式"></a>flex的对齐方式</h3><blockquote>
<p> 弹性布局的一大优点就是元素可以方便的对齐或居中</p>
</blockquote>
<br>

<h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><blockquote>
<p>定义了项目在<strong>主轴上的对齐方式</strong></p>
</blockquote>
<ul>
<li>flex-start: 主轴起始点对齐(默认值)</li>
<li>flex-end: 主轴结束点对齐</li>
<li>center: 居中</li>
<li>space-between: 两端对齐, 项目之间的间距相等</li>
<li>space-around: 两端离边框有一定间距</li>
</ul>
<p><img src="/img/%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/justify-content.gif" alt="justify-content"></p>
<br>

<h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><blockquote>
<p>定义了项目在<strong>交叉轴上的对齐方式</strong></p>
</blockquote>
<ul>
<li>flex-start: 交叉轴起始点对齐</li>
<li>flex-end: 交叉轴结束点对齐</li>
<li>center: 居中</li>
<li>stretch: 如果项目未设置高度或设为auto,撑满整个容器的高度(默认值)</li>
<li>baseline: 项目的第一行文字的基线对齐</li>
</ul>
<p><img src="/img/%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/align-items.gif" alt="align-items"></p>
<br>

<h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><blockquote>
<p>定义了<strong>多行</strong>在交叉轴上的对齐方式,如果只有<strong>一行则不起作用</strong></p>
</blockquote>
<ul>
<li>flex-start: 交叉轴起始点对齐</li>
<li>flex-end: 交叉轴结束点对齐</li>
<li>center: 居中</li>
<li>space-between: 两端对齐, 项目之间的间距相等</li>
<li>space-around: 两端离边框有一定间距</li>
</ul>
<p><img src="/img/%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/align-content.png" alt="align-content"></p>
<br>

<h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><blockquote>
<p>设置<strong>单个项目的对齐方式</strong>, 需在项目中定义</p>
<p>属性值和align-items一致</p>
</blockquote>
<p><img src="/img/%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/align-self.gif" alt="align-self"></p>
<br>

<h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><blockquote>
<p>在项目中定义,可以指定项目的排列顺序,数值越小越靠前,最小为0.</p>
</blockquote>
<p><img src="/img/%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/order.jpeg" alt="order"></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的数组</title>
    <url>/2020/12/22/js%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　Array类型( 数组 )是<a href="https://blog.fundebug.com/2017/11/22/details-about-javascript-and-ecmascript/" target="_blank" rel="noopener">ECMAScript</a>中常用的一种<strong>引用类型</strong>,相比于其他语言,ECMAScript中的Array类型有以下一些<strong>特性</strong>:</p>
<ul>
<li>数组中每一项都可以保存任意类型的数据</li>
<li>数组的大小可以动态调整,会随着数据的添加而自动增长</li>
</ul>
<h2 id="如何创建一个数组"><a href="#如何创建一个数组" class="headerlink" title="如何创建一个数组"></a>如何创建一个数组</h2><blockquote>
<p>有两种方式:</p>
</blockquote>
<h3 id="使用Array构造函数"><a href="#使用Array构造函数" class="headerlink" title="使用Array构造函数"></a>使用Array构造函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var animal &#x3D; new Array();</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<blockquote>
<p>如果知道数组要保存的项目个数也可以直接<strong>定义数组个数</strong>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var animal &#x3D; new Array(20); &#x2F;&#x2F;创建了一个包含20项的数组</span><br></pre></td></tr></table></figure>

<blockquote>
<p>你还可以直接<strong>定义数组中的值</strong>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var animal &#x3D; new Array(&#39;dog&#39;,&#39;cat&#39;,&#39;pig&#39;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果嫌麻烦你还可以<strong>省略<code>new</code>操作符</strong>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar animal &#x3D; Array(3);</span><br><span class="line">var animal &#x3D; Array(&#39;dog&#39;,&#39;cat&#39;,&#39;pig&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="使用字面量表示"><a href="#使用字面量表示" class="headerlink" title="使用字面量表示"></a>使用字面量表示</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar animal &#x3D; [&#39;dog&#39;,&#39;cat&#39;,&#39;pig&#39;]; &#x2F;&#x2F;创建了一个包含3项的数组</span><br><span class="line">var animal &#x3D; []; &#x2F;&#x2F;创建了一个空数组</span><br></pre></td></tr></table></figure>



<h2 id="读取和设置数组的值"><a href="#读取和设置数组的值" class="headerlink" title="读取和设置数组的值"></a>读取和设置数组的值</h2><blockquote>
<p>可以用以下方法:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar animal &#x3D; [&#39;dog&#39;,&#39;cat&#39;,&#39;pig&#39;];</span><br><span class="line"></span><br><span class="line">console.log(animal[0]); &#x2F;&#x2F;输出了animal数组的第一个值, 即 dog</span><br><span class="line">console.log(animal[&#39;1&#39;]); &#x2F;&#x2F;索引还可以为字符串类型, 取得了第二个值</span><br><span class="line"></span><br><span class="line">animal[1]&#x3D;&#39;duck&#39;; &#x2F;&#x2F;将animal数组的第二项修改为 duck</span><br><span class="line">animal[3]&#x3D;&#39;bird&#39;; &#x2F;&#x2F;新增了第四项 bird</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数组有一个<strong>length属性</strong>表示<strong>数组的项数</strong>, 同时它还是<strong>可更改</strong>的, 可以通过设置这个属性来向数组的末尾添加新项,或者删减数组</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar animal &#x3D; [&#39;dog&#39;,&#39;cat&#39;,&#39;pig&#39;];</span><br><span class="line"></span><br><span class="line">console.log(animal.length); &#x2F;&#x2F;输出animal数组的项数,3</span><br><span class="line"></span><br><span class="line">animal.length &#x3D; 4; &#x2F;&#x2F;增加了一个项目</span><br><span class="line">console.log(animal[3]); &#x2F;&#x2F;输出增加的项目,为undefined,即未赋值</span><br><span class="line"></span><br><span class="line">animal.length &#x3D; 2; &#x2F;&#x2F;删减为了两项</span><br><span class="line">console.log(animal[2]); &#x2F;&#x2F;为undefined,即未找到</span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用length还可以方便的在<strong>数组末尾添加新项</strong>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar animal &#x3D; [&#39;dog&#39;,&#39;cat&#39;,&#39;pig&#39;];</span><br><span class="line">animal[animal.length] &#x3D; &#39;bird&#39;; &#x2F;&#x2F;在末尾添加了新项</span><br><span class="line">animal[animal.length] &#x3D; &#39;duck&#39;; &#x2F;&#x2F;在末尾添加了新项</span><br></pre></td></tr></table></figure>

<p> 小知识: 数组最多可以包含 4294967 个项.</p>
<h2 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h2><blockquote>
<p>要确定一个对象是不是数组,可以使用<strong><code>instanceof</code>操作符</strong>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYif(value instanceof Array)&#123;</span><br><span class="line">    &#x2F;&#x2F;对数组执行某些操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　但是这样存在一个<strong>问题</strong>, <code>instanceof</code>操作符实际上是<strong>比较两个对象的构造函数</strong>, 检查某个对象的原型链是否包含某个构造函数的 <strong>prototype 属性</strong>, 假定的是一个单一的全局环境, 如果存在两个以上不同的全局环境,从而存在两个以上不同版本的 Array 构造函数, 这个时候就会<strong>发生错误</strong>.</p>
<p>　　为了避免这个问题,可以使用 ECMAScript5 新增的 <strong><code>Array.isArray()</code> 方法</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYif(Array.isArray(value))&#123;</span><br><span class="line">    &#x2F;&#x2F;执行某些操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　或者用以下方式,自己定义一个<strong>检测函数</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYfunction isArray(value)&#123;</span><br><span class="line">    return Object.prototype.toString.call(value) &#x3D;&#x3D; &quot;[Object Array]&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h2><h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><blockquote>
<p>将数组转换为字符串的方法</p>
</blockquote>
<h4 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h4><p>　　所有对象都具有 <code>toLocaleString()</code> <code>toString()</code> <code>valueOf()</code> 方法. 而调用数组的<code>toString()</code>方法会返回数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串. 而调用 <code>valueOf()</code> 方法返回的是数组本身. <code>toLocaleString()</code> 方法和 <code>toString()</code> 方法返回相同.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar color &#x3D; [&#39;red&#39;,&#39;blue&#39;,&#39;yellow&#39;];</span><br><span class="line"></span><br><span class="line">console.log(color.toString()); &#x2F;&#x2F;red,blue,yellow(相当于每个值都调用了 toString() 方法)</span><br><span class="line">console.log(color.valueOf()); &#x2F;&#x2F;数组本身</span><br><span class="line">console.log(color.toLocaleString()); &#x2F;&#x2F;red,blue,yellow (相当于每个值都调用了 toLocaleString() 方法)</span><br></pre></td></tr></table></figure>



<h4 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h4><blockquote>
<p>可以使用<strong>指定的符号</strong>来分隔值,接受一个<strong>参数</strong>即分隔符,然后<strong>返回</strong>包含所有数组项的字符串</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar color &#x3D; [&#39;red&#39;,&#39;blue&#39;,&#39;yellow&#39;];</span><br><span class="line"></span><br><span class="line">console.log(color.join(&#39;+&#39;)); &#x2F;&#x2F;red+blue+yellow</span><br><span class="line">console.log(color.join(&#39;|&#39;)); &#x2F;&#x2F;red|blue|yellow</span><br><span class="line">console.log(color.join()); &#x2F;&#x2F;red,blue,yellow</span><br></pre></td></tr></table></figure>



<h3 id="添加和删除方法"><a href="#添加和删除方法" class="headerlink" title="添加和删除方法"></a>添加和删除方法</h3><h4 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h4><ul>
<li>向数组的最后面添加元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYArray.push(value);</span><br></pre></td></tr></table></figure>

<ul>
<li>向数组的最前面添加元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYArray.unshift(value);</span><br></pre></td></tr></table></figure>



<h4 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h4><ul>
<li>删除数组的第一个元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYArray.shift();</span><br></pre></td></tr></table></figure>

<ul>
<li>删除数组的最后一个元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYArray.pop();</span><br></pre></td></tr></table></figure>



<h4 id="splice-方法"><a href="#splice-方法" class="headerlink" title="splice()方法"></a>splice()方法</h4><blockquote>
<p><code>splice()</code> 方法算是数组中最强大的方法了,它集合了<strong>删除,插入,替换</strong>功能. 它始终会返回<strong>一个包含删除项的数组</strong></p>
</blockquote>
<ul>
<li>删除</li>
</ul>
<blockquote>
<p>可以<strong>删除任意数量的项</strong>, 指定两个参数: 要删除的第一项的位置和要删除的项数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar color &#x3D; [&#39;red&#39;,&#39;blue&#39;,&#39;yellow&#39;];</span><br><span class="line">var removed &#x3D; color.splice(1,2);</span><br><span class="line"></span><br><span class="line">console.log(color); &#x2F;&#x2F;red</span><br><span class="line">console.log(removed); &#x2F;&#x2F;blue,yellow</span><br></pre></td></tr></table></figure>

<ul>
<li>插入</li>
</ul>
<blockquote>
<p>可以向指定的位置<strong>插入任意数量的项</strong>, 指定三个参数: 起始位置, 0(要删除的项数) ,要插入的项(可以多个)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar color &#x3D; [&#39;red&#39;,&#39;blue&#39;,&#39;yellow&#39;];</span><br><span class="line">var removed &#x3D; color.splice(1,0,&#39;black&#39;,&#39;green&#39;);</span><br><span class="line"></span><br><span class="line">console.log(color); &#x2F;&#x2F;red,blue,black,green,yellow</span><br><span class="line">console.log(removed); &#x2F;&#x2F;空数组</span><br></pre></td></tr></table></figure>

<ul>
<li>替换 (其实就是删除和插入的合并)</li>
</ul>
<blockquote>
<p>可以向指定的位置<strong>插入任意项同时删除任意项</strong>,指定三个参数: 起始位置, 要删除的项数, 要插入的项(可以多个)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar color &#x3D; [&#39;red&#39;,&#39;blue&#39;,&#39;yellow&#39;];</span><br><span class="line">var removed &#x3D; color.splice(1,1,&#39;black&#39;,&#39;green&#39;);</span><br><span class="line"></span><br><span class="line">console.log(color); &#x2F;&#x2F;red,black,green,yellow</span><br><span class="line">console.log(removed); &#x2F;&#x2F;blue</span><br></pre></td></tr></table></figure>



<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><ul>
<li><code>reverse()</code> 方法</li>
</ul>
<blockquote>
<p>会<strong>反转</strong>数组项的顺序</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar number &#x3D; [1,2,3,4,5];</span><br><span class="line">number.reverse();</span><br><span class="line">console.log(number); &#x2F;&#x2F;5,4,3,2,1</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sort()</code> 方法</li>
</ul>
<blockquote>
<p>默认按<strong>升序进行排列</strong>, 而且会调用每个项的 <code>toString()</code> 方法, <strong>比较字符串</strong>, 即使每一项都是数值也是如此.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar number &#x3D; [0,1,5,10,15];</span><br><span class="line">number.sort();</span><br><span class="line">console.log(number); &#x2F;&#x2F;0,1,10,15,5</span><br></pre></td></tr></table></figure>

<p>　　可以看出,其实这样并不是我们想要的效果，所以 <code>sort()</code> 还可以接收一个<strong>比较函数</strong>作为参数, 以便我们指定哪个值位于哪个值的前面. 比较函数接受<strong>两个参数</strong>同时返回<strong>三个值</strong>. 并有一下几个情况:</p>
<ul>
<li>返回一个负值,意味第一个参数位于第二个参数之前</li>
<li>返回一个正数,意味第一个参数位于第二个参数之后</li>
<li>返回0,意味两个参数相等</li>
</ul>
<blockquote>
<p>所以可以如下设计:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY&#x2F;&#x2F;这是一个升序的效果</span><br><span class="line">function compare1(value1,value2)&#123;</span><br><span class="line">    if(value1 &lt; value2)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;else if(value1 &gt; value2)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这是一个降序的效果</span><br><span class="line">function compare2(value1,value2)&#123;</span><br><span class="line">    if(value1 &gt; value2)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;else if(value1 &lt; value2)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>然后向 <code>sort()</code> 传入这个函数:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar number &#x3D; [0,1,5,10,15];</span><br><span class="line"></span><br><span class="line">number.sort(compare1);</span><br><span class="line">console.log(number); &#x2F;&#x2F;0,1,5,10,15</span><br><span class="line"></span><br><span class="line">number.sort(compare2);</span><br><span class="line">console.log(number); &#x2F;&#x2F;15,10,5,1,0</span><br></pre></td></tr></table></figure>

<p>　　其实对于数值类型数组或者 <code>valueOf()</code> 方法会返回数值类型的数组, 可以使用一个更简单的比较函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY&#x2F;&#x2F;和上面的升序函数效果是一样的</span><br><span class="line">function compare1(value1,value2)&#123;</span><br><span class="line">    return value1 - value2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;和上面的降序函数效果是一样的</span><br><span class="line">function compare2(value1,value2)&#123;</span><br><span class="line">    return value2 - value1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><ul>
<li><code>concat()</code> 方法</li>
</ul>
<blockquote>
<p>在没有传参的情况下,相当于<strong>复制了数组</strong>,传参会将<strong>参数添加到数组末尾</strong>, 原数组始终<strong>保持不变</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar animal &#x3D; [&#39;dog&#39;,&#39;cat&#39;,&#39;pig&#39;];</span><br><span class="line"></span><br><span class="line">var animal2 &#x3D; animal.concat();</span><br><span class="line">var animal3 &#x3D; animal.concat(&#39;bird&#39;,[apple,banana]);</span><br><span class="line"></span><br><span class="line">console.log(animal); &#x2F;&#x2F;dog,cat,pig</span><br><span class="line">console.log(animal2); &#x2F;&#x2F;dog,cat,pig</span><br><span class="line">console.log(animal3); &#x2F;&#x2F;dog,cat,pig,bird,apple,banana</span><br></pre></td></tr></table></figure>

<ul>
<li><code>slice()</code> 方法</li>
</ul>
<blockquote>
<p>接受<strong>一或两个参数</strong>作为起始值和结束值来<strong>复制截取数组</strong>, 一个参数时从参数开始截取到数组末尾, 两个参数时第一个参数开始到第二个参数结束(不包含第二个参数位置的值), 同样的<strong>不会改变原数组</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar animal &#x3D; [&#39;dog&#39;,&#39;cat&#39;,&#39;pig&#39;,&#39;bird&#39;,&#39;duck&#39;];</span><br><span class="line"></span><br><span class="line">var animal2 &#x3D; animal.slice(2);</span><br><span class="line">var animal3 &#x3D; animal.slice(2,4);</span><br><span class="line"></span><br><span class="line">console.log(animal); &#x2F;&#x2F;dog,cat,pig,bird,duck</span><br><span class="line">console.log(animal2); &#x2F;&#x2F;pig,bird,duck</span><br><span class="line">console.log(animal3); &#x2F;&#x2F;pig,bird</span><br></pre></td></tr></table></figure>



<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>　　有两个, <code>indexOf()</code> 和 <code>lastIndexOf()</code>,都接受两个参数: 要<strong>查找的项</strong>和<strong>查找起点位置索引</strong>(可选). 两者的区别是: <code>indexOf()</code> 是从<strong>开头向后查找</strong>, <code>lastIndexOf()</code> 是从<strong>末尾向前查找</strong>.</p>
<blockquote>
<p>返回值是项在<strong>数组中的位置</strong>,如果没有找到会<strong>返回-1</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar number &#x3D; [1,2,3,4,5,4,3,2,1];</span><br><span class="line"></span><br><span class="line">console.log(number.indexOf(4)); &#x2F;&#x2F;3</span><br><span class="line">console.log(number.lastIndexOf(4)); &#x2F;&#x2F;5</span><br><span class="line"></span><br><span class="line">console.log(number.indexOf(4,4)); &#x2F;&#x2F;5</span><br><span class="line">console.log(number.lastIndexOf(4,4)); &#x2F;&#x2F;3</span><br><span class="line"></span><br><span class="line">console.log(number.indexOf(8)); &#x2F;&#x2F;-1</span><br></pre></td></tr></table></figure>



<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><blockquote>
<p>迭代方法通俗来讲就是对数组中<strong>每个项目进行一些操作</strong>, 一般接受一个参数,即一个<strong>操作函数</strong>, 这个函数有三个参数: <strong>项的值, 项的位置, 数组本身</strong></p>
</blockquote>
<ul>
<li><code>every()</code> 方法和 <code>some()</code> 方法</li>
</ul>
<p>　　用于查询<strong>数组中的项是否满足某一条件</strong>, <code>every()</code> 和 <code>some()</code> 的区别其实类似于逻辑运算中<strong>与和或</strong>的区别, <code>every()</code> 需要所有的项都满足条件才会返回 <code>true</code> , 而 <code>some()</code> 只要有一个项满足条件就会返回 <code>true</code> .</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar number &#x3D; [1,2,3,4,5,4,3,2,1];</span><br><span class="line"></span><br><span class="line">var everyResult &#x3D; number.every(function(item,index,array)&#123;</span><br><span class="line">    return (item &gt; 2);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(everyResult); &#x2F;&#x2F;false</span><br><span class="line"></span><br><span class="line">var someResult &#x3D; number.some(function(item,index,array)&#123;</span><br><span class="line">    return (item &gt; 2);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(someResult); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<ul>
<li><code>filter()</code> 方法</li>
</ul>
<blockquote>
<p><code>filter()</code> 方法返回数组中<strong>符合条件的项</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar number &#x3D; [1,2,3,4,5,4,3,2,1];</span><br><span class="line"></span><br><span class="line">var filterResult &#x3D; number.filter(function(items,index,array)&#123;</span><br><span class="line">    return (items &gt; 2);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(filterResult); &#x2F;&#x2F;[3,4,5,4,3]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>map</code> 函数</li>
</ul>
<blockquote>
<p>对<strong>每个项执行操作</strong>, 然后返回<strong>执行完操作后的数组</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar number &#x3D; [1,2,3,4,5,4,3,2,1];</span><br><span class="line"></span><br><span class="line">var mapResult &#x3D; number.map(function(items,index,array)&#123;</span><br><span class="line">    return item * 2;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(mapResult); &#x2F;&#x2F;[2,4,6,8,10,8,6,4,2]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>forEach()</code> 方法</li>
</ul>
<blockquote>
<p>也是对<strong>每个项执行操作</strong>, 但没有返回值, 经常用它来遍历数组</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar number &#x3D; [1,2,3,4,5,4,3,2,1];</span><br><span class="line"></span><br><span class="line">number.forEach(function(items,index,array)&#123;</span><br><span class="line">    &#x2F;&#x2F;执行操作</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="缩小方法"><a href="#缩小方法" class="headerlink" title="缩小方法"></a>缩小方法</h3><ul>
<li><code>reduce()</code> 方法和 <code>reduceRight()</code> 方法</li>
</ul>
<p>　　接受两个参数: 一个在每项上都调用的函数, 一个初始值(可选). 调用函数有四个参数: 前一次调用函数返回的值(第一次调用函数时使用 <code>reduce()</code> 方法的初始值(如果有的话)), 当前的项, 当前项的索引, 数组对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPYvar number &#x3D; [1,2,3,4,5];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;一个累加的效果</span><br><span class="line">var sum &#x3D; number.reduce(function(prev,cur,index,array)&#123;</span><br><span class="line">    return prev+cur;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(sum); &#x2F;&#x2F;15</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;reduceRight就是从反方向开始</span><br><span class="line">var sum &#x3D; number.reduceRight(function(prev,cur,index,array)&#123;</span><br><span class="line">    return prev+cur;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(sum); &#x2F;&#x2F;15</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://segmentfault.com/a/1190000010731933#item-1" target="_blank" rel="noopener">JS进阶篇–JS数组reduce()方法详解及高级技巧 </a>推一篇文章</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈js的内存</title>
    <url>/2020/12/24/%E8%B0%88%E8%B0%88js%E7%9A%84%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h2 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h2><p>不管什么程序语言，内存生命周期基本是一致的：  </p>
<ol>
<li>分配你所需要的内存</li>
<li>使用分配到的内存（读、写）</li>
<li>不需要时将其释放\归还</li>
</ol>
<p>所有语言第二部分都是明确的。第一和第三部分在底层语言中是明确的，但在像JavaScript这些高级语言中，大部分都是隐含的。</p>
<a id="more"></a>

<h3 id="js的内存分配"><a href="#js的内存分配" class="headerlink" title="js的内存分配"></a>js的内存分配</h3><p>为了不让程序员费心分配内存，JavaScript 在定义变量时就完成了内存分配。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>; <span class="comment">// 给数值变量分配内存</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"azerty"</span>; <span class="comment">// 给字符串分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">null</span></span><br><span class="line">&#125;; <span class="comment">// 给对象及其包含的值分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给数组及其包含的值分配内存（就像对象一样）</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">"abra"</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">2</span>;</span><br><span class="line">&#125; <span class="comment">// 给函数（可调用的对象）分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式也能分配一个对象</span></span><br><span class="line">someElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  someElement.style.backgroundColor = <span class="string">'blue'</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>函数调用结果分配对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 分配一个 Date 对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>); <span class="comment">// 分配一个 DOM 元素</span></span><br></pre></td></tr></table></figure>

<p>方法分配新变量或者新对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"azerty"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s.substr(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// s2 是一个新的字符串</span></span><br><span class="line"><span class="comment">// 因为字符串是不变量，</span></span><br><span class="line"><span class="comment">// JavaScript 可能决定不分配内存，</span></span><br><span class="line"><span class="comment">// 只是存储了 [0-3] 的范围。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">"ouais ouais"</span>, <span class="string">"nan nan"</span>];</span><br><span class="line"><span class="keyword">var</span> a2 = [<span class="string">"generation"</span>, <span class="string">"nan nan"</span>];</span><br><span class="line"><span class="keyword">var</span> a3 = a.concat(a2); </span><br><span class="line"><span class="comment">// 新数组有四个元素，是 a 连接 a2 的结果</span></span><br></pre></td></tr></table></figure>

<h3 id="js内存的使用"><a href="#js内存的使用" class="headerlink" title="js内存的使用"></a>js内存的使用</h3><p>使用值的过程实际上是对分配内存进行读取与写入的操作。 读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">// 分配内存</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 对内存的使用</span></span><br></pre></td></tr></table></figure>

<h3 id="js的内存回收"><a href="#js的内存回收" class="headerlink" title="js的内存回收"></a>js的内存回收</h3><p>javascript具有<strong>自动垃圾收集机制</strong>,也就是说,执行环境负责管理代码执行过程中使用的内存.</p>
<h4 id="标记清除-mark-and-sweep"><a href="#标记清除-mark-and-sweep" class="headerlink" title="标记清除(mark-and-sweep)"></a>标记清除(mark-and-sweep)</h4><p>最常用的js内存回收机制,主要工作流程如下:</p>
<ol>
<li>给内存中的所有变量加上标记</li>
<li>去掉环境中的变量和被环境中的变量引用的变量的标记</li>
<li>将那些之后再被加上标记的变量视为待删除变量</li>
<li>销毁带标记的值并回收内存空间</li>
</ol>
<h4 id="引用计数-reference-counting"><a href="#引用计数-reference-counting" class="headerlink" title="引用计数(reference counting)"></a>引用计数(reference counting)</h4><p>不太常见,且存在循环引用问题,引用计数有以下几个点:</p>
<ul>
<li>声明了一个变量并将一个引用类型的值赋给了该变量,那么这个值得引用次数为1</li>
<li>如果这个值又被赋给另一个变量,那它次数+1</li>
<li>如果引用这个值的某个变量取得了另外一个值,那它次数-1</li>
<li>当这个值的引用次数为0时,就说明已经没有办法再访问这个值了,回收该值的内存空间</li>
</ul>
<p>而正因为这个机制,引用计数有个问题:<strong>循环引用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="keyword">var</span> b=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    </span><br><span class="line">    a.someObject=b;</span><br><span class="line">    b.someObject=a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上,其中a和b两个变量互相引用,导致函数执行后,两个对象都离开了作用域但还是没有释放内存,因为他们的引用计数永远都不是0</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>就像之前的循环引用问题,或者我们的一些不规范操作.都会使内存无法及时释放,从而引起内存泄漏</p>
<p>如此内存占用就会越来越高,影响系统性能甚至进程崩溃.</p>
<h3 id="如何判断内存泄漏"><a href="#如何判断内存泄漏" class="headerlink" title="如何判断内存泄漏"></a>如何判断内存泄漏</h3><p>如果连续五次垃圾回收之后,内存占用一次比一次大,就存在内存泄漏</p>
<h3 id="几种常见的内存泄露"><a href="#几种常见的内存泄露" class="headerlink" title="几种常见的内存泄露"></a>几种常见的内存泄露</h3><h4 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//未定义的变量会在全局中创建一个新变量</span></span><br><span class="line">    bar=<span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bar=<span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用之后this指向了全局对象,而不是undefined</span></span><br><span class="line">foo2();</span><br></pre></td></tr></table></figure>

<p>当全局变量用于临时存储和处理大量信息的时候,确保用完之后将其设置为null或重新定义</p>
<blockquote>
<p>在javascript文件头部加上<code>use strict</code>启用严格模式可以避免此类错误发生</p>
</blockquote>
<h4 id="被遗忘的定时器和回调函数"><a href="#被遗忘的定时器和回调函数" class="headerlink" title="被遗忘的定时器和回调函数"></a>被遗忘的定时器和回调函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> today=getDate();</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> node=<span class="built_in">document</span>.getElementById(<span class="string">'Node'</span>);</span><br><span class="line">    <span class="keyword">if</span>(node)&#123;</span><br><span class="line">        node.innerHTML=<span class="built_in">JSON</span>.stringify(today);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>如上,当node元素被移除之后,该函数是没有用处的,但还是一直在运行</p>
<h4 id="DOM引用"><a href="#DOM引用" class="headerlink" title="DOM引用"></a>DOM引用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements=&#123;</span><br><span class="line">    button:<span class="built_in">document</span>.getElementById(<span class="string">'button'</span>),</span><br><span class="line">    image:doucment.getElementById(<span class="string">'image'</span>),</span><br><span class="line">    text:<span class="built_in">document</span>.getElementById(<span class="string">'text'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSome</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    image.src=<span class="string">'www.hello.com'</span>;</span><br><span class="line">    button.click();</span><br><span class="line">    <span class="built_in">console</span>.log(text.innerHTML);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeButton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//当移除了dom树中的引用之后,还是有一个引用在全局中</span></span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'button'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你在代码中保存了一个<code>&lt;tr&gt;</code>的引用,当你删除了整个<code>&lt;table&gt;</code>并不会只保留了这个<code>&lt;tr&gt;</code>的引用,而是整个<code>&lt;table&gt;</code>因为子元素和父元素存在引用的关系</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> originalThing = theThing;</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (originalThing)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  theThing = &#123;</span><br><span class="line">    longStr: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'*'</span>),</span><br><span class="line">    someMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(someMessage);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">setInterval(replaceThing, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>如上,由于闭包的特性</p>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>js的内存空间分为<strong>栈(</strong>stack)、<strong>堆</strong>(heap)、<strong>池</strong>(一般也会归类为栈中)。</p>
<p>其中<strong>栈存放变量，堆存放复杂对象，池存放常量</strong>，所以也叫常量池。</p>
<h3 id="栈数据结构"><a href="#栈数据结构" class="headerlink" title="栈数据结构"></a>栈数据结构</h3><p>栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。 栈被称为是一种后入先出（LIFO，last-in-first-out）的数据结构。 </p>
<p><img src="/img/js%E5%86%85%E5%AD%98/%E6%A0%88%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.jpg" alt="栈内存结构"></p>
<h3 id="堆数据结构"><a href="#堆数据结构" class="headerlink" title="堆数据结构"></a>堆数据结构</h3><p>堆（heap）也被称为优先队列（priority queue）。队列中允许的操作是先进先出（FIFO），在队尾插入元素，在队头取出元素。而堆也是一样，在堆底插入元素，在堆顶取出元素，但是堆中元素的排列不是按照到来的先后顺序，而是按照一定的优先顺序排列的。这个优先顺序可以是元素的大小或者其他规则。</p>
<h2 id="变量类型与内存的关系"><a href="#变量类型与内存的关系" class="headerlink" title="变量类型与内存的关系"></a>变量类型与内存的关系</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>基本数据类型共有6种：</p>
<ol>
<li>Sting</li>
<li>Number</li>
<li>Boolean</li>
<li>null</li>
<li>undefined</li>
<li>Symbol</li>
</ol>
<p>基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> num2=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/img/js%E5%86%85%E5%AD%98/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.jpg" alt="基本数据类型"></p>
<blockquote>
<p>闭包中的基本类型变量不保存在栈内存中,而是在堆内存中</p>
</blockquote>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p><a href="https://segmentfault.com/a/1190000006752076" target="_blank" rel="noopener">引用数据类型</a>存储在堆内存中，因为引用数据类型占据空间大、大小不固定。 如果存储在栈中，将会影响程序运行的性能； 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本数据类型-栈内存</span></span><br><span class="line"><span class="keyword">let</span> a1=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a2=<span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">let</span> a2=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的指针在栈内存中,对象本身在堆内存中</span></span><br><span class="line"><span class="keyword">let</span> b1=&#123;</span><br><span class="line">    name:<span class="string">'dog'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b2=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当我们<strong>访问堆内存中的引用数据类型</strong>的时候,实际上是先<strong>获取了栈内存中的地址指针,然后根据指针去找到堆内存中的数据</strong>.而因为这个原因,当我们复制了一个引用数据类型,然后修改它的复制体,原来的引用类型也会跟随着改变,因为我们复制的不过是一个引用地址,而改变的是它们共同引向的值</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>内存</tag>
        <tag>原理</tag>
      </tags>
  </entry>
</search>
